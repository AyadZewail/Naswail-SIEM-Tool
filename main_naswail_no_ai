import sys
import numpy as np
import pandas as pd
import time
import multiprocessing
import psutil
import os
import ipaddress
from sklearn.svm import OneClassSVM
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import QPainter, QPixmap
import matplotlib.pyplot as plt
from scapy.all import *
from statistics import mean, median, mode, stdev, variance
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error, r2_score
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from datetime import datetime, timedelta
from home import Ui_MainWindow
from nasanalysis import SecondaryWidget

time_series = {}
packetInput = 0
packetFile = None
clearRead = 0
packetIndex = 0

class PacketSnifferThread(QThread):
    packet_captured = pyqtSignal(object)
    readPackets = []

    def run(self):
        
        
        global packetInput, packetFile, packetIndex
        print(packetInput)
        window.packets.clear()
        window.tableWidget.setRowCount(0)
        match packetInput:
            case 0:
                
                sniff(prn=self.emit_packet, store=False, stop_filter=lambda _: packetInput != 0)
            case 1:
                try:
                    packets = rdpcap(packetFile)
                    for packet in packets:
                        self.packet_captured.emit(packet)
                except Exception as e:
                    print(f"Error reading pcap file: {e}")
            case 2:
                try:
                    self.readPackets = pd.read_csv(packetFile)
                    for _, row in self.readPackets.iterrows():
                        self.packet_captured.emit(row)
                except Exception as e:
                    print(f"Error reading CSV file: {e}")

    def emit_packet(self, packet):
        self.packet_captured.emit(packet)


class Naswail(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.showMaximized()

        global packetInput, clearRead
        #
        #line edit
        # Apply white background (#FFFFFF) to all QLineEdits
       # Apply oceanic blue background (#1E3A3A) to all QLineEdits
        # Apply gradient background to QLineEdits
        # Apply dark black background color to QLineEdits
        # Apply navy blue background color to QLineEdits
        # Apply grey background color to QLineEdits
       # Apply light off-white background color to QLineEdits
        self.lineEdit.setStyleSheet("""
            QLineEdit {
                background-color: grey
            }
        """)
        self.lineEdit_2.setStyleSheet("""
            QLineEdit {
                background-color: grey;
            }
        """)
        self.lineEdit_3.setStyleSheet("""
            QLineEdit {
                background-color: grey;
            }
        """)
        self.lineEdit_4.setStyleSheet("""
            QLineEdit {
                background-color: grey
            }
        """)
        self.lineEdit_5.setStyleSheet("""
            QLineEdit {
                background-color: grey;
            }
        """)





        
        

        #line edit related bug fix
        self.filterapplied=False
        #
        self.total_inside_packets=0
        self.total_outside_packets=0
        self.pushButton.clicked.connect(self.resetfilter)
        self.packets = []
        self.captured_packets = []
        self.filtered_packets = []
        self.packet_features = []
        self.new_packet_features = []
        self.sen_ct=0
        self.sensors = {}
        self.sen_info=[]
        self.packet_stats = {"total": 0, "tcp": 0, "udp": 0, "icmp": 0}
        self.model = LinearRegression()
        self.anmodel = OneClassSVM(kernel='rbf', gamma=0.1, nu=0.1)
        self.bandwidth_data = []
        #self.bandwidth=[]
        self.times = []
        self.counts = []
        self.anomalies = []
        self.apps = dict()
        self.futureTraffic = 0
        self.r2 = 0
        self.senFlag = -1
        self.capture = -1
        self.start_time = QTime.currentTime()
        self.elapsedTime = 0
        self.show_donut_chart()
        self.scene = QGraphicsScene(self)
        self.ct_sensor_packet=[]
        self.sensors_name=[]
        # Load an image into QPixmap
        pixmap = QPixmap(r"logo.jpg")  # Replace with the path to your image file

        #Logo Image
        self.pixmap_item = QGraphicsPixmapItem(pixmap)
        self.scene.addItem(self.pixmap_item)
        self.graphicsView.setScene(self.scene)
        self.graphicsView.setFixedSize(71, 61)
        self.graphicsView.fitInView(self.scene.sceneRect(), Qt.AspectRatioMode.KeepAspectRatio)

        self.tableWidget.setColumnCount(10)
        self.tableWidget.setHorizontalHeaderLabels(["Timestamp", "Source", "Destination", "Protocol","macsrc","macdst","srcport","dstport","length","IP version"])
        self.tableWidget.cellClicked.connect(self.display_packet_details)
        self.tabWidget.currentChanged.connect(lambda index: self.get_applications_with_ports() if index == 3 else None)

       
            

        

        self.tableWidget_2.setColumnCount(2)
        self.tableWidget_2.setHorizontalHeaderLabels(["Name", "IP"])
        self.tableWidget_2.cellClicked.connect(self.apply_filter)
        
        self.tableWidget_3.setColumnCount(3)
        self.tableWidget_3.setHorizontalHeaderLabels(["Port", "Application", "Status"])
        self.tableWidget_3.cellClicked.connect(self.analyze_app)

        self.pushButton_5.clicked.connect(self.toggleCapture)
        self.pushButton_6.clicked.connect(self.toggleCapture)
        self.pushButton_7.clicked.connect(self.toggleSenFlag)

        self.actionImport_Packets.triggered.connect(self.import_file)
        self.actionExport_Packets.triggered.connect(self.export_packets)
        self.actionExport_Packets.triggered.connect(self.resetInput)

        self.buttonBox_2.clicked.connect(lambda _: self.addSensor(1))
        self.buttonBox_2.rejected.connect(lambda _: self.addSensor(2))
        
        # Connect checkboxes to the apply_filter method
        self.checkBox.stateChanged.connect(self.apply_filter)      # UDP
        self.checkBox_2.stateChanged.connect(self.apply_filter)    # TCP
        self.checkBox_3.stateChanged.connect(self.apply_filter)    # ICMP
        self.checkBox_4.stateChanged.connect(self.apply_filter)    # DNS
        self.checkBox_5.stateChanged.connect(self.apply_filter)    # DHCP
        self.checkBox_6.stateChanged.connect(self.apply_filter)    # HTTP
        self.checkBox_7.stateChanged.connect(self.apply_filter)    # HTTPS
        self.checkBox_8.stateChanged.connect(self.apply_filter)    # TELNET
        self.checkBox_9.stateChanged.connect(self.apply_filter)    # FTP
        self.checkBox_10.stateChanged.connect(self.apply_filter)   # Other
        self.pushButton_9.clicked.connect(self.apply_filter)

        self.sniffer_thread = PacketSnifferThread()
        self.sniffer_thread.packet_captured.connect(self.process_packet)
        self.sniffer_thread.start()

        self.stats_timer = QTimer()
        self.stats_timer.timeout.connect(self.tick)
        self.stats_timer.start(1000)
        self.ct = 0
        self.pushButton_2.clicked.connect(self.open_analysis)
    
    
    def open_analysis(self):
            
            self.secondary_widget = SecondaryWidget(self)  # Pass reference to the main window
            self.hide()
            self.secondary_widget.show()
    
    def resetfilter(self):
        self.filterapplied=False
        checkboxes = [
            self.checkBox,
            self.checkBox_2,
            self.checkBox_3,
            self.checkBox_4,
            self.checkBox_5,
            self.checkBox_6,
            self.checkBox_7,
            self.checkBox_8,
            self.checkBox_9,
            self.checkBox_10
        ]
        for checkbox in checkboxes:
            checkbox.setCheckState(Qt.CheckState.Unchecked)
        self.filterapplied = False
    #end of reset filter

    def process_packet(self, packet):
        try:
            timestamp = float(packet.time)
            readable_time = datetime.fromtimestamp(timestamp).strftime("%I:%M:%S %p")
            src_ip = packet["IP"].src if packet.haslayer("IP") else "N/A"
            dst_ip = packet["IP"].dst if packet.haslayer("IP") else "N/A"
            islocal=False
            islocal=self. is_local_ip(src_ip)
            if islocal==True:
                self.total_inside_packets+=1
            else:
                self.total_outside_packets+=1
            
            protocol = self.get_protocol(packet)

            # Extract MAC addresses
            macsrc = packet["Ethernet"].src if packet.haslayer("Ethernet") else "N/A"
            macdst = packet["Ethernet"].dst if packet.haslayer("Ethernet") else "N/A"
            # Extract packet length
            packet_length = int(len(packet))

        # Extract IP version
            ip_version = "IPv6" if packet.haslayer("IPv6") else "IPv4" if packet.haslayer("IP") else "N/A"
            # Extract port information for TCP/UDP
            sport = None
            dport = None
            if packet.haslayer("TCP"):
                sport = packet["TCP"].sport
                dport = packet["TCP"].dport
            elif packet.haslayer("UDP"):
                sport = packet["UDP"].sport
                dport = packet["UDP"].dport

            packet_length = int(len(packet))

            self.packet_stats["total"] += 1
            if protocol.lower() == "tcp":
                self.packet_stats["tcp"] += 1
            elif protocol.lower() == "udp":
                self.packet_stats["udp"] += 1
            elif protocol.lower() == "icmp":
                self.packet_stats["icmp"] += 1

           
            
            # Add to table
            row_position = self.tableWidget.rowCount()
            if self.filterapplied:
                self.apply_filter()
            elif self.senFlag == 1:
                pass
            else:
                self.packets.append(packet)
                if self.capture == 1:
                    self.captured_packets.append(packet)
                self.new_packet_features.append([packet_length, timestamp, protocol])

                self.tableWidget.insertRow(row_position)
                self.tableWidget.setItem(row_position, 0, QTableWidgetItem(readable_time))
                self.tableWidget.setItem(row_position, 1, QTableWidgetItem(src_ip))
                self.tableWidget.setItem(row_position, 2, QTableWidgetItem(dst_ip))
                self.tableWidget.setItem(row_position, 3, QTableWidgetItem(protocol))

                # Add MAC addresses and port info to the table
                self.tableWidget.setItem(row_position, 4, QTableWidgetItem(macsrc))
                self.tableWidget.setItem(row_position, 5, QTableWidgetItem(macdst))
                self.tableWidget.setItem(row_position, 6, QTableWidgetItem(str(sport) if sport else "N/A"))
                self.tableWidget.setItem(row_position, 7, QTableWidgetItem(str(dport) if dport else "N/A"))
                self.tableWidget.setItem(row_position, 8, QTableWidgetItem(str(packet_length)))
                self.tableWidget.setItem(row_position, 9, QTableWidgetItem(ip_version))

            time_series[timestamp] = len(self.packets)

            if len(self.bandwidth_data) == 0 or self.bandwidth_data[-1][0] != readable_time:
                self.bandwidth_data.append((readable_time, len(packet)))
            else:
                self.bandwidth_data[-1] = (readable_time, self.bandwidth_data[-1][1] + len(packet))

        except Exception as e:
            print(f"Error processing packet: {e}")

    def get_protocol(self, packet):
        if packet.haslayer("IP"):
            ip_proto = packet["IP"].proto
            if ip_proto == 17:  # UDP protocol
                return "udp"
            elif ip_proto == 6:  # TCP protocol
                # Check for specific transport protocols in the TCP layer
                if packet.haslayer("TCP"):
                    sport = packet["TCP"].sport
                    dport = packet["TCP"].dport
                    if dport == 21 or sport == 21:
                        return "ftp"
                    elif dport == 23 or sport == 23:
                        return "telnet"
                    elif dport == 443 or sport == 443:
                        return "https"
                    elif dport == 80 or sport == 80:
                        return "http"
                    else:
                        return "tcp"
            elif ip_proto == 1:  # ICMP protocol
                return "icmp"
            elif ip_proto == 17:  # DNS is over UDP
                if packet.haslayer("UDP") and packet["UDP"].dport == 53:
                    return "dns"
            elif ip_proto == 17:  # DHCP is also UDP
                if packet.haslayer("UDP"):
                    if packet["UDP"].dport in [67, 68]:
                        return "dhcp"
            else:
                return "Other"
        else:
            return "Other"


    def display_packet_details(self, row, column):
        try:
            if self.filterapplied==False:
                 
                 
                 packet = self.packets[row]
                 details = packet.show(dump=True)  # Get packet details as a string
                 detailslist = details.split("\n")
                 model = QStringListModel()
                 model.setStringList(detailslist)
                 self.listView.setModel(model)
                        
            if self.filterapplied==True:

                packet = self.filtered_packets[row]
                details = packet.show(dump=True)  # Get packet details as a string
                detailslist = details.split("\n")
                model = QStringListModel()
                model.setStringList(detailslist)
                self.listView.setModel(model)
        except Exception as e:
            print(f"Error displaying packet details: {e}")

    def tick(self):
        current_time = QTime.currentTime()
        elapsed_seconds = self.start_time.secsTo(current_time)
        hours = elapsed_seconds // 3600
        minutes = (elapsed_seconds % 3600) // 60
        seconds = elapsed_seconds % 60
        self.elapsedTime = f"{hours:02}:{minutes:02}:{seconds:02}"
        self.label_6.setText(str(self.elapsedTime))

    def get_applications_with_ports(self):
        apps_with_ports = []

        for proc in psutil.process_iter(attrs=['pid', 'name', 'exe', 'status']):
            try:
                pid = proc.info['pid']
                app_name = proc.info['name']
                app_path = proc.info['exe']
                app_status = proc.info['status']

                connections = psutil.Process(pid).net_connections(kind='inet')
                for conn in connections:
                    local_ip, local_port = conn.laddr
                    apps_with_ports.append({
                        "Application": app_name,
                        "IP": local_ip,
                        "Port": local_port,
                        "Path": app_path,
                        "Status": app_status
                    })
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                continue

        self.apps = apps_with_ports
        self.tableWidget_3.setRowCount(0)
        for app in self.apps:
            row_position = self.tableWidget_3.rowCount()
            self.tableWidget_3.insertRow(row_position)
            self.tableWidget_3.setItem(row_position, 0, QTableWidgetItem(str(app["Port"])))
            self.tableWidget_3.setItem(row_position, 1, QTableWidgetItem(str(app["Application"])))
            self.tableWidget_3.setItem(row_position, 2, QTableWidgetItem(str(app["IP"])))

    def analyze_app(self, row):
        self.filterapplied=True
        target_app = self.apps[row]
        self.tableWidget.setRowCount(0)
       
        self.filtered_packets = []
        for packet in self.packets:
            macsrc = packet["Ethernet"].src if packet.haslayer("Ethernet") else "N/A"
            macdst = packet["Ethernet"].dst if packet.haslayer("Ethernet") else "N/A"
            # Extract packet length
            packet_length = int(len(packet))

        # Extract IP version
            ip_version = "IPv6" if packet.haslayer("IPv6") else "IPv4" if packet.haslayer("IP") else "N/A"
            # Extract port information for TCP/UDP
            sport = None
            dport = None
            if packet.haslayer("TCP"):
                sport = packet["TCP"].sport
                dport = packet["TCP"].dport
            elif packet.haslayer("UDP"):
                sport = packet["UDP"].sport
                dport = packet["UDP"].dport

            packet_length = int(len(packet))
            src_ip = packet["IP"].src if packet.haslayer("IP") else "N/A"
            dst_ip = packet["IP"].dst if packet.haslayer("IP") else "N/A"
            protocol = self.get_protocol(packet)
            port = packet["TCP"].sport if packet.haslayer("TCP") else "N/A"

            if target_app["IP"] in src_ip.lower() or target_app["IP"] in dst_ip.lower() or str(target_app["Port"]) in str(port):
                self.filtered_packets.append(packet)

                row_position = self.tableWidget.rowCount()
                self.tableWidget.insertRow(row_position)
                self.tableWidget.setItem(row_position, 0, QTableWidgetItem(datetime.fromtimestamp(packet.time).strftime("%I:%M:%S %p")))
                self.tableWidget.setItem(row_position, 1, QTableWidgetItem(src_ip))
                self.tableWidget.setItem(row_position, 2, QTableWidgetItem(dst_ip))
                self.tableWidget.setItem(row_position, 3, QTableWidgetItem(protocol))
                   # Add MAC addresses and port info to the table
                self.tableWidget.setItem(row_position, 4, QTableWidgetItem(macsrc))
                self.tableWidget.setItem(row_position, 5, QTableWidgetItem(macdst))
                self.tableWidget.setItem(row_position, 6, QTableWidgetItem(str(sport) if sport else "N/A"))
                self.tableWidget.setItem(row_position, 7, QTableWidgetItem(str(dport) if dport else "N/A"))
                self.tableWidget.setItem(row_position, 8, QTableWidgetItem(str(packet_length)))
                self.tableWidget.setItem(row_position, 9, QTableWidgetItem(ip_version))

    def toggleCapture(self):
        if self.capture == 1:
            print(self.captured_packets)
            self.captured_packets.clear()
        self.capture *= -1

    def import_file(self):
        global packetFile, packetInput
        packetFile, _ = QFileDialog.getOpenFileName(self, "Open File", "", "All Files ();;PCAP Files (.pcap);;CSV Files (*.csv)")

        if packetFile:
            print(f"Selected file: {packetFile}")
            ext = os.path.splitext(packetFile)[1].lower()
            if ext == '.pcap':
                packetInput = 1
            elif ext == '.csv':
                packetInput = 2
            PacketSnifferThread.run(self.sniffer_thread)
        else:
            print("No file selected")

    def export_packets(self):
        try:
            wrpcap("captured_packets.pcap", self.packets)
            print("Packets exported successfully.")
        except Exception as e:
            print(f"Error exporting packets: {e}")

    def resetInput(self):
        global packetIndex, packetInput, clearRead
        packetInput, packetIndex, clearRead = 0, 0, 0

    def addSensor(self, a):
        senName = self.lineEdit_3.text().strip()
        senIP = self.lineEdit_4.text().strip()
        
        if(a == 1):
            self.sen_info.append(senName)
            self.sen_info.append(0)
            self.sensors[senName] = senIP
        else:
            del self.sensors[senName]
        self.sensors_name.append(senName)
        print(self.sensors)
        plt.close()
        self.show_donut_chart()
        self.displaySensorTable()

    def displaySensorTable(self):
        self.show_donut_chart
        self.tableWidget_2.setRowCount(0)
        for name, ip in self.sensors.items():
            
            row_position = self.tableWidget_2.rowCount()
            self.tableWidget_2.insertRow(row_position)
            self.tableWidget_2.setItem(row_position, 0, QTableWidgetItem(str(name)))
            self.tableWidget_2.setItem(row_position, 1, QTableWidgetItem(str(ip)))

    def toggleSenFlag(self):
        self.senFlag *= -1
        if self.senFlag == 1:
            self.tableWidget.setRowCount(0)

            for packet in self.packets:
                src_ip = packet["IP"].src if packet.haslayer("IP") else "N/A"
                dst_ip = packet["IP"].dst if packet.haslayer("IP") else "N/A"
                protocol = self.get_protocol(packet)
                port = packet["TCP"].sport if packet.haslayer("TCP") else "N/A"
               
                for sensor_name, sensor_ip in self.sensors.items():
                    if sensor_ip.lower() in src_ip.lower() or sensor_ip.lower() in dst_ip.lower():
                       
                        for s in range(0,len(self.sen_info)-1,2):
                            if self.sen_info[s]==sensor_name:
                               
                            
                               self. sen_info[s+1]+=1
                           
                             
                        row_position = self.tableWidget.rowCount()
                        self.tableWidget.insertRow(row_position)
                        
                        self.tableWidget.setItem(row_position, 0, QTableWidgetItem(datetime.fromtimestamp(packet.time).strftime("%I:%M:%S %p")))
                        self.tableWidget.setItem(row_position, 1, QTableWidgetItem(src_ip))
                        self.tableWidget.setItem(row_position, 2, QTableWidgetItem(dst_ip))
                        self.tableWidget.setItem(row_position, 3, QTableWidgetItem(protocol))
                
            self.ct_sensor_packet.append(self.sen_ct)
                
    
    def is_local_ip(self,ip):
        """Check if an IP address is private (local)."""
        try:
            ip_obj = ipaddress.ip_address(ip)
            return ip_obj.is_private  # Returns True for private IPs, False otherwise
        except ValueError:
            return False  # Handle invalid IP addresses gracefully
   

    def show_donut_chart(self):
        # Data for the chart
        sizes = [1]  # Percentages
        labels = ['']  # Empty labels to hide text
        s=0
        for s in range(len(self.sensors)):
            sizes.append(s)
            labels.append('')
        #end of for
        colors = ['#ff4d4d', '#3399ff', '#33ff33']  # Custom colors
        
        # Create the figure and axes
        fig, ax = plt.subplots(figsize=(6, 6))  # Set size of the figure
        
        # Draw the donut chart
        wedges, texts = ax.pie(
            sizes,
            labels=labels,
            startangle=90,
            colors=colors,
            wedgeprops=dict(width=0.3)  # Create the "donut" effect
        )
        
        # Set aspect ratio to be equal
        ax.axis('equal')
        ax.set_title('Sensors')
        
        # Ensure transparency
        fig.patch.set_visible(False)  # Completely hide the figure background
        ax.patch.set_alpha(0)         # Transparent axes background
        
        # Render the figure to a Qt widget
        canvas = FigureCanvas(fig)
        canvas.setStyleSheet("background: transparent;")  # Ensure no background for the canvas
        canvas.setGeometry(0, 0, self.graphicsView_2.width(), self.graphicsView_2.height())
        
        # Set up a transparent scene for QGraphicsView
        scene = QGraphicsScene()
        scene.setBackgroundBrush(Qt.GlobalColor.transparent)  # Ensure the scene background is transparent
        scene.addWidget(canvas)
        self.graphicsView_2.setScene(scene)


    def apply_filter(self):
        """Filter packets based on selected protocols, source/destination IPs, and ComboBox selection."""
        # Map checkbox states to protocol names
        protocol_filters = {
            "udp": self.checkBox.isChecked(),
            "tcp": self.checkBox_2.isChecked(),
            "icmp": self.checkBox_3.isChecked(),
            "dns": self.checkBox_4.isChecked(),
            "dhcp": self.checkBox_5.isChecked(),
            "http": self.checkBox_6.isChecked(),
            "https": self.checkBox_7.isChecked(),
            "telnet": self.checkBox_8.isChecked(),
            "ftp": self.checkBox_9.isChecked(),
            "other": self.checkBox_10.isChecked(),
        }
        self.filterapplied = True

        # Determine which protocols to filter
        selected_protocols = [protocol for protocol, checked in protocol_filters.items() if checked]

        # Get the source and destination IP filters
        src_filter = self.lineEdit_2.text().strip()
        dst_filter = self.lineEdit_5.text().strip()

        # Get ComboBox selection
        combo_selection = self.comboBox.currentText()  # 'Inside' or 'Outside'

        # Clear the table before adding filtered packets
        self.tableWidget.setRowCount(0)

        # Filter packets
        self.filtered_packets = []
        if(self.senFlag == -1):
            x = self.packets
        else:
            x = self.sensors
        for packet in x:
            src_ip = packet["IP"].src if packet.haslayer("IP") else "N/A"
            dst_ip = packet["IP"].dst if packet.haslayer("IP") else "N/A"
            protocol = self.get_protocol(packet)

            # Determine if source/destination IPs are local
            src_is_local = self.is_local_ip(src_ip)
            dst_is_local = self.is_local_ip(dst_ip)

            # Check if the packet matches the selected protocols
            protocol_match = protocol in selected_protocols if selected_protocols else True

            # Check source and destination filters
            src_match = src_filter in src_ip if src_filter else True
            dst_match = dst_filter in dst_ip if dst_filter else True

            # Check ComboBox selection
            if combo_selection == "Inside":
                ip_match = src_is_local and dst_is_local
            elif combo_selection == "Outside":
                ip_match = not src_is_local or not dst_is_local
            else:
                ip_match = True  # Default: no filter based on inside/outside

            # Include packet if it matches all criteria
            if protocol_match and src_match and dst_match and ip_match:

                self.filtered_packets.append(packet)
                macsrc = packet["Ethernet"].src if packet.haslayer("Ethernet") else "N/A"
                macdst = packet["Ethernet"].dst if packet.haslayer("Ethernet") else "N/A"
                # Extract packet length
                packet_length = int(len(packet))

            # Extract IP version
                ip_version = "IPv6" if packet.haslayer("IPv6") else "IPv4" if packet.haslayer("IP") else "N/A"
                # Extract port information for TCP/UDP
                sport = None
                dport = None
                if packet.haslayer("TCP"):
                    sport = packet["TCP"].sport
                    dport = packet["TCP"].dport
                elif packet.haslayer("UDP"):
                    sport = packet["UDP"].sport
                    dport = packet["UDP"].dport

                row_position = self.tableWidget.rowCount()
                self.tableWidget.insertRow(row_position)
                self.tableWidget.setItem(row_position, 0, QTableWidgetItem(datetime.fromtimestamp(float(packet.time)).strftime("%I:%M:%S %p")))
                self.tableWidget.setItem(row_position, 1, QTableWidgetItem(src_ip))
                self.tableWidget.setItem(row_position, 2, QTableWidgetItem(dst_ip))
                self.tableWidget.setItem(row_position, 3, QTableWidgetItem(protocol))
                   # Add MAC addresses and port info to the table
                self.tableWidget.setItem(row_position, 4, QTableWidgetItem(macsrc))
                self.tableWidget.setItem(row_position, 5, QTableWidgetItem(macdst))
                self.tableWidget.setItem(row_position, 6, QTableWidgetItem(str(sport) if sport else "N/A"))
                self.tableWidget.setItem(row_position, 7, QTableWidgetItem(str(dport) if dport else "N/A"))
                self.tableWidget.setItem(row_position, 8, QTableWidgetItem(str(packet_length)))
                self.tableWidget.setItem(row_position, 9, QTableWidgetItem(ip_version))
        self.apply_filter=False
    #end of filter



if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Naswail()
    window.show()
    sys.exit(app.exec())
